
See the paper (scanalyzer.pdf) in this directory.

Helmert, Malte, and Hauke Lasinger.
"The Scanalyzer domain: Greenhouse logistics as a planning problem."
ICAPS2010

Abstract:

Scanalyzer planning domain, a domain for
classical planning which models the problem of automatic
greenhouse logistic management.

At its mathematical core, the Scanalyzer domain is a permutation problem with
striking similarities to common search benchmarks such as Rubikâ€™s Cube or
TopSpin. At the same time, it is also a real application domain, and efficient
algorithms for the problem are of considerable practical interest.
The Scanalyzer domain was used as a benchmark for sequential planners at the
last International Planning Competition.  The competition results show that
domain-independent automated planners can find solutions of comparable quality
to those generated by specialized algorithms developed by domain experts, while
being considerably more flexible.

---

usage: generator.py [-h] [--seed SEED] [--output OUTPUT] size half_segment_ids inout

The environment contains N conveyers and an imaging chamber.
`size` argument specifies N, the number of conveyers.

When half_segment_ids == "ab" is given, each conveyer belt is split into 2 segments,
which can move individually.

`inout` specifies how many conveyers are connected to the imaging chamber.
If none, only one converyer goes into the chamber, and only one converyer is connected to the outlet of the chamber.
If in, all converyers goes into the chamber, but only one converyer is connected to the exit of the chamber.
If both, all converyers can go into the chamber, and come out of the chamber.
Internally, they are stored in `problem_type` variable.

`problem_type` can be a string "simple", in which case there is an additional conveyer named "segback"
(segbacka , segbackb in the case of half segments)
that can be seen as an extra storage space that is empty initially.

---

IPC08 instances:

prob_no = 1
for half_segment_ids in [ [""], ["a", "b"] ]:
    for size in xrange(1,11):
        for problem_type in [ (1,1), (size,1), (1,size), (size,size), "simple" ]:
            filename = "p%03d.pddl" % prob_no
            create_pddl(half_segment_ids, problem_type, size, prob_no, filename)
            prob_no += 1

Selection in IPC:

(half_segment_ids, problem_type, size)
11: [''], (1, 1), 3
12: [''], (3, 1), 3
14: [''], (3, 3), 3
16: [''], (1, 1), 4
17: [''], (4, 1), 4
19: [''], (4, 4), 4
21: [''], (1, 1), 5
22: [''], (5, 1), 5
24: [''], (5, 5), 5
26: [''], (1, 1), 6
27: [''], (6, 1), 6
29: [''], (6, 6), 6
31: [''], (1, 1), 7
32: [''], (7, 1), 7
34: [''], (7, 7), 7
36: [''], (1, 1), 8
37: [''], (8, 1), 8
39: [''], (8, 8), 8
41: [''], (1, 1), 9
42: [''], (9, 1), 9
44: [''], (9, 9), 9
51: ['a', 'b'], (1, 1), 1
52: ['a', 'b'], (1, 1), 1
54: ['a', 'b'], (1, 1), 1
56: ['a', 'b'], (1, 1), 2
57: ['a', 'b'], (2, 1), 2
59: ['a', 'b'], (2, 2), 2
61: ['a', 'b'], (1, 1), 3
62: ['a', 'b'], (3, 1), 3
64: ['a', 'b'], (3, 3), 3
