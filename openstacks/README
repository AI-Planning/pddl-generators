generate_problems.cpp:

Ioannis's program for generating the text files that define the
Openstacks instances. The ICAPS benchmark set was created with
something like the following calls:

./generate_problems  5  34  1 1 1 XXX
./generate_problems  5  20  5 1 3 XXX
./generate_problems 30  60 10 1 3 XXX
./generate_problems 80 100 20 1 3 XXX

where XXX is the density parameter which has unfortunately been lost
(20? 25? 30? 40?). For generating additional benchmark instances, the
Python script (below) should be preferred.


Notes on attribute selection:
  - A very high-density seems to simplify the problem with blind search.
  - For OPT in IPC'08 they scaled both products and orders at the same time,
    with a linear scaling of +1
  - For SAT, in IPC'14 they started at 170 for both. The scaling factor was +20
    in both cases.


generate_problems.py:

A Python version of Ioannis's program which fixes a few issues with
the C++ program:

 * When an order is empty, some product is chosen uniformly randomly
   to make it nonempty. Due to an off-by-one error, the last product
   could never be chosen for this.

 * Similarly, unused products would randomly be added to one order.
   Due to an off-by-one error, the last order could never be selected
   for this.

 * The original code shuffled the orders after generating the problem
   matrix. However, this shuffling was not completely uniform. To see
   this, consider e.g. a 5x5 problem, where the shuffling algorithm
   would uniformly compute ten random numbers in the range {0, ...,
   4}, which gives 5^10 atomic events with uniform probability. From
   this random information, it's not possible to select between 5! =
   120 permutations uniformly since 120 does not divide 5^10.

 * More seriously, the original code did not shuffle the products.
   Adjacent products are correlated in that they tend to be useful for
   the same orders, so this may introduce some bias for planners that
   for whatever (tie-breaking) reason process the products in some
   kind of sequential order.


generate_pddl.cpp:

Ioannis's program for generating PDDL code from the text files
generated by generate_problems. Need to change various global
variables (opt, sat, all, ADL, negated, semiground, temporal, numeric,
net_benefit) to affect which problem set is generated.


generator.py:

Combination of generate_problems.py and generate_pddl.cpp in Python. This
generator version can only generate the sequential STRIPS version with
negative preconditions. In contrast to the original generator files, this
script only generates a single task per call.



From IPC'11:

Openstacks

From the original domain description: This domain was first used at IPC-2006.
The openstacks domain is based on the "minimum maximum simultaneous open stacks"
combinatorial optimization problem, which can be stated as follows: A
manufacturer has a number of orders, each for a combination of different
products, and can only make one product at a time.

The total required quantity of each product is made at the same time (because
changing from making one product to making another requires a production stop).
From the time that the first product included in an order is made to the time
that all products included in the order have been made, the order is said to be
"open" and during this time it requires a "stack" (a temporary storage space).
The problem is to order the making of the different products so that the maximum
number of stacks that are in use simultaneously, or equivalently the number of
orders that are in simultaneous production, is minimized (because each stack
takes up space in the production area).

The problem is NP-hard and known to be equivalent to several other problems. It
was recently posed as a challenge problem for the constraint programming
community (see http://www.dcs.st-and.ac.uk/~ipg/challenge/).

Note that this is an optimization problem: for any instance of the problem every
ordering of the making of products is a solution, which at worst uses as many
simultaneously open stacks as there are orders. Thus, finding a plan is quite
trivial (in the sense that there exists a domain-specific linear-time algorithm
that solves the problem), but finding a plan of high quality is hard (even for a
domain-specific algorithm).

There are two versions of this domain, STRIPS and ADL. As there are few ADL
compliant planners and in the last IPC there were not too much differences in
results between both versions, we have not generated ADL problems for this IPC.
In the STRIPS version the goal is to minimize the total number of stacks. The
number of stacks is represented using symbols and universally quantified
preconditions have been replaced by multiple semi-ground actions. Note that this
requires a different domain file for each problem.

For the satisficing track, in the 2008 competition, objects ranged from 5 to
100. For the first 12 problems, three versions with the same difficulty were
created and objects were increased by 5 from one triplet to the next (i.e.
problems 1, 2 and 3 were similar, with 5 objects; problems 4, 5 and 6 had 10
objects...). From 13 to 24 objects were increased by 10, while for the last 6,
objects were increased by 20. The density parameter has been lost. For IPC 2011,
as in the other reused domains, we reused the 10 first problems. From 11 to 20,
objects are increased starting from 130 by 30, and 2 problems of the same size
have been created, one with density = 20 and the other with density = 80.

The selected problems are (numbers in parenthesis are number of objects of each
new problem):

problem	old	best	problem	old	best
p01	p21	6	p11	(130)
p02	p22	16	p12	(130)
p03	p24	19	p13	(160)
p04	p25	19	p14	(160)
p05	p26	15	p15	(190)
p06	p27	18	p16	(190)
p07	p20	13	p17	(220)
p08	p28	33	p18	(220)
p09	p29	31	p19	(250)
p10	p30	35	p20	(250)

For the optimal track, in the IPC 2008 a total of 9 problems were not solved by
any planner (problem 20 and from 23 to 30). As in the satisficing version, there
is no record of the density used to generate the problems. The first problem in
IPC 2008 started with 5 objects and each problem had 1 object more than the
previous one. So problem 30 had 34 objects.

Five first problems were quite simple so they have been removed from the
selection. This results in 16 problems previously solved and 4 non solved for
this edition. The selected problems are:

problem	old	optimal		problem	old	optimal
p01	p6	2		p11	p15	4
p02	p7	5		p12	p16	4
p03	p8	5		p13	p17	4
p04	p9	3		p14	p18	3
p05	p10	3		p15	p19	4
p06	p11	4		p16	p21	3
p07	p12	3		p17	p20	-
p08	p13	4		p18	p23	-
p09	p14	4		p19	p24	-
p10	p22	4		p20	p25	-
